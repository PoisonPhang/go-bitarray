// Copyright (c) 2021 Hirotsuna Mizuno. All rights reserved.
// Use of this source code is governed by the MIT license that can be found in
// the LICENSE file.

package bitarray_test

import (
	"testing"

	"github.com/tunabay/go-bitarray"
)

func TestBitArray_TrailingZeros(t *testing.T) {
	tcs := []struct {
		s string
		n int
	}{
		{"", 0},
		{"1", 0},
		{"10", 1},
		{"110", 1},
		{"1110", 1},
		{"0", 1},
		{"00", 2},
		{"000", 3},
		{"0000", 4},
		{"0000-0", 5},
		{"0000-00", 6},
		{"0000-000", 7},
		{"0000-0000", 8},
		{"0000-0000 0", 9},
		{"0000-0000 00", 10},
		{"0000-0000 000", 11},
		{"0000-0000 0000", 12},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000", 36},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-000", 39},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000", 40},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0", 41},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000", 44},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000", 48},
		{"0001-000", 3},
		{"0001-0000", 4},
		{"0001-0000 0", 5},
		{"0001-0001", 0},
		{"0001-0000 1", 0},
		{"0001-0001 00", 2},
		{"0001-0000 100", 2},
		{"1100-0000 1011-0", 1},
		{"1100-0000 1011-00", 2},
		{"1100-0000 1011-000", 3},
		{"1100-0000 1011-0000", 4},
		{"1100-0000 1011-0000 0", 5},
		{"1100-0000 1011-0000 1", 0},
		{"1100-0000 1011-0000 10", 1},
		{"1100-0000 1011-0000 11", 0},
		{"1010-0000 0000-0000 00", 15},
		{"1010-0000 0000-0000 0000-0000 00", 23},
		{"1010-0000 0000-0000 0000-0000 0000-0000", 29},
		{"1010-0000 0000-0000 0000-0000 0000-0000 0", 30},
		{"1010-0000 0000-0000 0000-0000 0000-0000 00", 31},
		{"1", 0},
		{"11", 0},
		{"111", 0},
		{"1111", 0},
		{"1111-1", 0},
		{"1111-11", 0},
		{"1111-111", 0},
		{"1111-1111", 0},
		{"1111-1111 0", 1},
		{"1111-1111 00", 2},
		{"1111-1111 1", 0},
		{"1111-1111 10", 1},
		{"1111-1111 1100-00", 4},
		{"1111-1111 1100-000", 5},
		{"1111-1111 1100-0000", 6},
		{"1111-1111 1100-0000 0", 7},
		{"1111-1111 1100-0000 00", 8},
		{"1111-1111 1111-111", 0},
		{"1111-1111 1111-1111", 0},
		{"1111-1111 1111-1111 1", 0},
		{"0000-0000 0000-0000 1111-1111 0000-0000 00", 10},
		{"0000-0000 0000-0000 1111-1110 0000-0000 00", 11},
		{"0000-0000 0000-0000 1111-1111 0000-0000 11", 0},
	}
	for _, tc := range tcs {
		for i := 0; i < 3; i++ {
			ba := bitarray.MustParse(tc.s)
			switch i {
			case 1:
				ba = ba.ZExpand()
			case 2:
				ba = ba.ZOptimize()
			}
			if n := ba.TrailingZeros(); n != tc.n {
				t.Errorf("unexpected result: got %d, want %d", n, tc.n)
				t.Logf("data: %#b", ba)
				t.Logf("data: %s", ba.D())
			}
		}
	}
}

func TestBitArray_LeadingZeros(t *testing.T) {
	tcs := []struct {
		s string
		n int
	}{
		{"", 0},
		{"1", 0},
		{"10", 0},
		{"110", 0},
		{"1110", 0},
		{"1110-0000", 0},
		{"1110-0000 0", 0},
		{"1000-0000 0000-0000", 0},
		{"1000-0000 0000-0000 0000-0000 0", 0},
		{"1000-0000 0000-0000 0000-0000 1", 0},
		{"1000-0000 0000-0000 0000-0000 01", 0},
		{"01", 1},
		{"001", 2},
		{"0001", 3},
		{"0", 1},
		{"00", 2},
		{"000", 3},
		{"0000", 4},
		{"0000-0", 5},
		{"0000-00", 6},
		{"0000-000", 7},
		{"0000-0000", 8},
		{"0000-0000 0", 9},
		{"0000-0000 00", 10},
		{"0000-0000 000", 11},
		{"0000-0000 0000", 12},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000", 36},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-000", 39},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000", 40},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0", 41},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000", 44},
		{"0000-0000 0000-0000 0000-0000 0000-0000 0000-0000 0000-0000", 48},
		{"0001-000", 3},
		{"0001-0000", 3},
		{"0001-0000 0", 3},
		{"0001-0001", 3},
		{"0001-0000 1", 3},
		{"0000-0000 0111-0", 9},
		{"0000-0000 1111-0", 8},
		{"0000-0001 0111-0", 7},
		{"0000-0010 0111-0", 6},
		{"0000-0100 0111-0", 5},
		{"0000-0000 0000-0000 0000-0000 01", 25},
		{"0000-0000 0000-0000 0000-0000 10", 24},
		{"0000-0000 0000-0000 0000-0001 00", 23},
		{"0000-0000 0000-0000 0001-0000 00", 19},
		{"0000-0000 0000-0000 1000-0000 00", 16},
		{"0000-0000 0000-0001 0000-0000 00", 15},
		{"0000-0000 0000-0000 0000-0000 0000-0000", 32},
		{"0000-0000 0000-0000 0000-0000 0000-0001", 31},
		{"0000-0000 0000-0000 0000-0000 0000-0010", 30},
		{"0000-0000 0000-0000 0000-0000 0001-0000", 27},
		{"0000-0000 0000-0000 0000-0000 1000-0000", 24},
	}
	for _, tc := range tcs {
		for i := 0; i < 3; i++ {
			ba := bitarray.MustParse(tc.s)
			switch i {
			case 1:
				ba = ba.ZExpand()
			case 2:
				ba = ba.ZOptimize()
			}
			if n := ba.LeadingZeros(); n != tc.n {
				t.Errorf("unexpected result: got %d, want %d", n, tc.n)
				t.Logf("data: %#b", ba)
				t.Logf("data: %s", ba.D())
			}
		}
	}
}

func TestBitArray_OnesCount(t *testing.T) {
	tcs := []struct {
		s string
		n int
	}{
		{"", 0},
		{"1", 1},
		{"10", 1},
		{"01", 1},
		{"000", 0},
		{"100", 1},
		{"001", 1},
		{"111", 3},
		{"0010", 1},
		{"0011-1100", 4},
		{"0100-0010 0", 2},
		{"1000-0011 1", 4},
		{"0000-0110 0011-1000", 5},
		{"0000-0000 0000-0000 0000-0000 00", 0},
		{"0000-0000 0000-0000 0000-0000 0000-0000", 0},
		{"0000-0000 0000-0000 0000-0000 01", 1},
		{"0010-0000 0000-1000 0001-0000 10", 4},
		{"0000-1111 1111-1111 1111-1111 1111-1111", 28},
		{"1111-1111 1111-1111 1111-1111 1111-1111", 32},
		{"1111-1111 1111-1111 1111-1111 1111-1111 111", 35},
		{"0111-1111 1111-1111 1111-1111 1111-1111 110", 33},
		{"0x_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_fff", 156},
		{"0x_ffff_0000_ffff_ffff_ffff_ffff_ffff_ffff_00ff_ff", 128},
	}
	for _, tc := range tcs {
		for i := 0; i < 3; i++ {
			ba := bitarray.MustParse(tc.s)
			switch i {
			case 1:
				ba = ba.ZExpand()
			case 2:
				ba = ba.ZOptimize()
			}
			if n := ba.OnesCount(); n != tc.n {
				t.Errorf("unexpected result: got %d, want %d", n, tc.n)
				t.Logf("data: %#b", ba)
				t.Logf("data: %s", ba.D())
			}
		}
	}
}

func TestBitArray_And(t *testing.T) {
	tdt := []string{
		"", "", "",
		"0", "0", "0",
		"1", "0", "0",
		"0", "1", "0",
		"1", "1", "1",
		"0101-0101", "0000-1010", "0000-0000",
		"0101-0101", "1100-0011", "0100-0001",
		"0000-0000 0000-0000", "0000-0000 0000-0000", "0000-0000 0000-0000",
		"0000-0000 0000-0000", "1111-1111 1111-1111", "0000-0000 0000-0000",
		"1111-1111 1111-1111", "0000-0000 0000-0000", "0000-0000 0000-0000",
		"0000-0000 0000-0000 0", "0000-0000 0000-0000 0", "0000-0000 0000-0000 0",
		"0000-0000 0000-0000 0", "0000-0000 1111-1111 0", "0000-0000 0000-0000 0",
		"0000-0000 0101-0101 0", "0000-0000 0000-0000 0", "0000-0000 0000-0000 0",
		"1111-1111 1111-1111 1", "1111-1111 1111-1111 1", "1111-1111 1111-1111 1",
		"1010-1010 1010-1010 1", "0101-0101 0101-0101 0", "0000-0000 0000-0000 0",

		"0x_00ff_ff00_0000_ffff_0000_00ff_ff00_ffff_0000_ffff_0000_ffff_000f_f0",
		"0x_0000_ffff_0000_0000_0000_ffff_0000_0000_0000_cafe_0000_39f0_0055_01",
		"0x_0000_ff00_0000_0000_0000_00ff_0000_0000_0000_cafe_0000_39f0_0005_00",
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
			t.FailNow()
		}
	}
	for i := 0; i < len(tdt); i += 3 {
		ba0 := bitarray.MustParse(tdt[i]).ZOptimize()
		ba1 := bitarray.MustParse(tdt[i+1]).ZOptimize()
		ba2 := bitarray.MustParse(tdt[i+2])
		ba0E := ba0.ZExpand()
		ba1E := ba1.ZExpand()
		chk(ba0.And(ba1), ba2)
		chk(ba0.And(ba1E), ba2)
		chk(ba0E.And(ba1), ba2)
		chk(ba0E.And(ba1E), ba2)
		chk(ba1.And(ba0), ba2)
		chk(ba1.And(ba0E), ba2)
		chk(ba1E.And(ba0), ba2)
		chk(ba1E.And(ba0E), ba2)
	}
	func() {
		var ba *bitarray.BitArray
		defer func() {
			if recover() == nil {
				t.Errorf("panic expected: got %#b", ba)
			}
		}()
		ba0 := bitarray.MustParse("0101-0101 01")
		ba1 := bitarray.MustParse("0101-01")
		ba = ba0.And(ba1)
	}()
}

func TestBitArray_Or(t *testing.T) {
	tdt := []string{
		"", "", "",
		"0", "0", "0",
		"1", "0", "1",
		"0", "1", "1",
		"1", "1", "1",
		"0101-0101", "0000-1010", "0101-1111",
		"0101-0101", "1100-0011", "1101-0111",
		"0000-0000 0000-0000", "0000-0000 0000-0000", "0000-0000 0000-0000",
		"0000-0000 0000-0000", "1111-1111 1111-1111", "1111-1111 1111-1111",
		"1111-1111 1111-1111", "0000-0000 0000-0000", "1111-1111 1111-1111",
		"0000-0000 0000-0000 0", "0000-0000 0000-0000 0", "0000-0000 0000-0000 0",
		"0000-0000 0000-0000 0", "0000-0000 1111-1111 0", "0000-0000 1111-1111 0",
		"0000-0000 0101-0101 0", "0000-0000 0000-0000 0", "0000-0000 0101-0101 0",
		"1111-1111 1111-1111 1", "1111-1111 1111-1111 1", "1111-1111 1111-1111 1",
		"1010-1010 1010-1010 1", "0101-0101 0101-0101 0", "1111-1111 1111-1111 1",

		"0x_0000_0000_0000_ffff_0000_0000_0000_ffff_0000_0000_0000_ffff_0000_00",
		"0x_0000_ffff_0000_0000_0000_ffff_0000_0000_0000_cafe_0000_0000_0055_01",
		"0x_0000_ffff_0000_ffff_0000_ffff_0000_ffff_0000_cafe_0000_ffff_0055_01",
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
			t.FailNow()
		}
	}
	for i := 0; i < len(tdt); i += 3 {
		ba0 := bitarray.MustParse(tdt[i]).ZOptimize()
		ba1 := bitarray.MustParse(tdt[i+1]).ZOptimize()
		ba2 := bitarray.MustParse(tdt[i+2])
		ba0E := ba0.ZExpand()
		ba1E := ba1.ZExpand()
		chk(ba0.Or(ba1), ba2)
		chk(ba0.Or(ba1E), ba2)
		chk(ba0E.Or(ba1), ba2)
		chk(ba0E.Or(ba1E), ba2)
		chk(ba1.Or(ba0), ba2)
		chk(ba1.Or(ba0E), ba2)
		chk(ba1E.Or(ba0), ba2)
		chk(ba1E.Or(ba0E), ba2)
	}
	func() {
		var ba *bitarray.BitArray
		defer func() {
			if recover() == nil {
				t.Errorf("panic expected: got %#b", ba)
			}
		}()
		ba0 := bitarray.MustParse("0101-0101 01")
		ba1 := bitarray.MustParse("0101-01")
		ba = ba0.Or(ba1)
	}()
}

func TestBitArray_Xor(t *testing.T) {
	tdt := []string{
		"", "", "",
		"0", "0", "0",
		"1", "0", "1",
		"0", "1", "1",
		"1", "1", "0",
		"0101-0101", "0000-1010", "0101-1111",
		"0101-0101", "1100-0011", "1001-0110",
		"0000-0000 0000-0000", "0000-0000 0000-0000", "0000-0000 0000-0000",
		"0000-0000 0000-0000", "1111-1111 1111-1111", "1111-1111 1111-1111",
		"1111-1111 1111-1111", "0000-0000 0000-0000", "1111-1111 1111-1111",
		"0000-0000 0000-0000 0", "0000-0000 0000-0000 0", "0000-0000 0000-0000 0",
		"0000-0000 0000-0000 0", "0000-0000 1111-1111 0", "0000-0000 1111-1111 0",
		"0000-0000 0101-0101 0", "0000-0000 0000-0000 0", "0000-0000 0101-0101 0",
		"1111-1111 1111-1111 1", "1111-1111 1111-1111 1", "0000-0000 0000-0000 0",
		"1010-1010 1010-1010 1", "0101-0101 0101-0101 0", "1111-1111 1111-1111 1",
		"1010-1010 1010-1010 1", "1111-0000 1111-1111 1", "0101-1010 0101-0101 0",

		"0x_0000_00ff_0000_ffff_0000_00ff_0000_ffff_0000_0000_0000_ffff_00f0_ff",
		"0x_0000_ffff_0000_0000_0000_ffff_0000_f0f0_f0f0_cafe_0000_0000_0055_01",
		"0x_0000_ff00_0000_ffff_0000_ff00_0000_0f0f_f0f0_cafe_0000_ffff_00a5_fe",
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
			t.FailNow()
		}
	}
	for i := 0; i < len(tdt); i += 3 {
		ba0 := bitarray.MustParse(tdt[i]).ZOptimize()
		ba1 := bitarray.MustParse(tdt[i+1]).ZOptimize()
		ba2 := bitarray.MustParse(tdt[i+2])
		ba0E := ba0.ZExpand()
		ba1E := ba1.ZExpand()
		chk(ba0.Xor(ba1), ba2)
		chk(ba0.Xor(ba1E), ba2)
		chk(ba0E.Xor(ba1), ba2)
		chk(ba0E.Xor(ba1E), ba2)
		chk(ba1.Xor(ba0), ba2)
		chk(ba1.Xor(ba0E), ba2)
		chk(ba1E.Xor(ba0), ba2)
		chk(ba1E.Xor(ba0E), ba2)
	}
	func() {
		var ba *bitarray.BitArray
		defer func() {
			if recover() == nil {
				t.Errorf("panic expected: got %#b", ba)
			}
		}()
		ba0 := bitarray.MustParse("0101-0101 01")
		ba1 := bitarray.MustParse("0101-01")
		ba = ba0.Xor(ba1)
	}()
}

func TestBitArray_Not(t *testing.T) {
	tdt := []string{
		"", "",
		"0", "1",
		"1", "0",
		"000", "111",
		"111", "000",
		"0101-0101", "1010-1010",
		"0101-0101 11", "1010-1010 00",
		"0000-0000 0000-000", "1111-1111 1111-111",
		"0000-0000 0000-0000", "1111-1111 1111-1111",
		"0000-0000 0000-0000 0", "1111-1111 1111-1111 1",
		"1111-1111 1111-111", "0000-0000 0000-000",
		"1111-1111 1111-1111", "0000-0000 0000-0000",
		"1111-1111 1111-1111 1", "0000-0000 0000-0000 0",
		"0000-1111 1111-0000 00", "1111-0000 0000-1111 11",
		"1010-1010 1010-1010 1010-1", "0101-0101 0101-0101 0101-0",
		"0x_f0f0_f0f0 0x_6969_6969 101", "0x_0f0f_0f0f 0x_9696_9696 010",
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
			t.FailNow()
		}
	}
	for i := 0; i < len(tdt); i += 2 {
		ba0 := bitarray.MustParse(tdt[i]).ZOptimize()
		exp := bitarray.MustParse(tdt[i+1])
		ba0E := ba0.ZExpand()
		chk(ba0.Not(), exp)
		chk(ba0E.Not(), exp)
	}
}

func TestBitArray_AndAt(t *testing.T) {
	tcs := []struct {
		off            int
		src, mask, dst string
	}{
		{0, "", "", ""},
		{3, "1111", "0", "1110"},
		{4, "1010", "", "1010"},
		{0, "0101-0101 01", "", "0101-0101 01"},
		{1, "0000-0000 00", "1111-1111", "0000-0000 00"},
		{2, "1111-1111 11", "0000", "1100-0011 11"},
		{10, "0101-0101 01", "", "0101-0101 01"},
		{1, "1111-0101 01", "0", "1011-0101 01"},
		{9, "1111-1111 11", "0", "1111-1111 10"},
		{6, "0000-0000 0000-0000 000", "1111-1111 1", "0000-0000 0000-0000 000"},
		{6, "1111-1111 1111-1111 111", "0000-0000 0", "1111-1100 0000-0001 111"},
		{7, "1111-1111 1111-1111 111", "0", "1111-1110 1111-1111 111"},
		{8, "1111-1111 1111-1111 111", "0", "1111-1111 0111-1111 111"},
		{9, "1111-1111 1111-1111 111", "0", "1111-1111 1011-1111 111"},
		{5, "1111-1111 1111-1111 111", "000", "1111-1000 1111-1111 111"},
		{6, "1111-1111 1111-1111 111", "000", "1111-1100 0111-1111 111"},
		{7, "1111-1111 1111-1111 111", "000", "1111-1110 0011-1111 111"},
		{8, "1111-1111 1111-1111 111", "000", "1111-1111 0001-1111 111"},
		{5, "1111-1111 1111-1111 1111-1111", "0000-0000 0000-0000", "1111-1000 0000-0000 0000-0111"},
		{5, "1111-1111 1111-1010 1111-1111", "0000-0000 1111-0000", "1111-1000 0000-0010 1000-0111"},
		{8, "1111-1111 0101-1010 1111-1111 11", "0000-1111", "1111-1111 0000-1010 1111-1111 11"},
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
		}
	}
	for _, tc := range tcs {
		ba0 := bitarray.MustParse(tc.src).ZOptimize()
		ba0E := ba0.ZExpand()
		ba1 := bitarray.MustParse(tc.mask).ZOptimize()
		ba1E := ba1.ZExpand()
		want := bitarray.MustParse(tc.dst)
		chk(ba0.AndAt(tc.off, ba1), want)
		chk(ba0.AndAt(tc.off, ba1E), want)
		chk(ba0E.AndAt(tc.off, ba1), want)
		chk(ba0E.AndAt(tc.off, ba1E), want)
	}
	// panics
	bap := bitarray.MustParse("1111")
	chkpanic := func(off int, xs string) {
		t.Helper()
		var ba *bitarray.BitArray
		x := bitarray.MustParse(xs)
		defer func() {
			t.Helper()
			if recover() == nil {
				t.Errorf("panic expected: off=%d, x=%#b: got %#b", off, x, ba)
			}
		}()
		ba = bap.AndAt(off, x)
	}
	chkpanic(-1, "010")
	chkpanic(0, "01010")
	chkpanic(3, "01")
}

func TestBitArray_OrAt(t *testing.T) {
	tcs := []struct {
		off            int
		src, mask, dst string
	}{
		{0, "", "", ""},
		{3, "1111", "0", "1111"},
		{4, "1010", "", "1010"},
		{0, "0101-0101 01", "", "0101-0101 01"},
		{1, "0000-0000 00", "1111-1111", "0111-1111 10"},
		{2, "1111-1111 11", "0000", "1111-1111 11"},
		{3, "1100-1010 11", "1010", "1101-1110 11"},
		{10, "0101-0101 01", "", "0101-0101 01"},
		{1, "1000-0101 01", "1", "1100-0101 01"},
		{9, "1111-1111 10", "1", "1111-1111 11"},
		{6, "0000-0000 0000-0000 000", "1111-1111 1", "0000-0011 1111-1110 000"},
		{6, "1111-1111 1111-1111 111", "0000-0000 0", "1111-1111 1111-1111 111"},
		{7, "0000-0000 0000-0000 000", "1", "0000-0001 0000-0000 000"},
		{8, "0000-0000 0000-0000 000", "1", "0000-0000 1000-0000 000"},
		{9, "0000-0000 0000-0000 000", "1", "0000-0000 0100-0000 000"},
		{5, "0000-0000 0000-0000 000", "111", "0000-0111 0000-0000 000"},
		{6, "0000-0000 0000-0000 000", "111", "0000-0011 1000-0000 000"},
		{7, "0000-0000 0000-0000 000", "111", "0000-0001 1100-0000 000"},
		{8, "0000-0000 0000-0000 000", "111", "0000-0000 1110-0000 000"},
		{5, "0000-0000 0000-0000 0000-0000", "1111-1111 1111-1111", "0000-0111 1111-1111 1111-1000"},
		{6, "0000-0000 0000-0000 0000-0000", "1111-1111 1111-1111", "0000-0011 1111-1111 1111-1100"},
		{8, "0000-0000 1010-0101 0000-0000 00", "1111-0000", "0000-0000 1111-0101 0000-0000 00"},
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
		}
	}
	for _, tc := range tcs {
		ba0 := bitarray.MustParse(tc.src).ZOptimize()
		ba0E := ba0.ZExpand()
		ba1 := bitarray.MustParse(tc.mask).ZOptimize()
		ba1E := ba1.ZExpand()
		want := bitarray.MustParse(tc.dst)
		chk(ba0.OrAt(tc.off, ba1), want)
		chk(ba0.OrAt(tc.off, ba1E), want)
		chk(ba0E.OrAt(tc.off, ba1), want)
		chk(ba0E.OrAt(tc.off, ba1E), want)
	}
	// panics
	bap := bitarray.MustParse("1111")
	chkpanic := func(off int, xs string) {
		t.Helper()
		var ba *bitarray.BitArray
		x := bitarray.MustParse(xs)
		defer func() {
			t.Helper()
			if recover() == nil {
				t.Errorf("panic expected: off=%d, x=%#b: got %#b", off, x, ba)
			}
		}()
		ba = bap.OrAt(off, x)
	}
	chkpanic(-1, "010")
	chkpanic(0, "01010")
	chkpanic(3, "01")
}

func TestBitArray_XorAt(t *testing.T) {
	tcs := []struct {
		off            int
		src, mask, dst string
	}{
		{0, "", "", ""},
		{3, "1111", "0", "1111"},
		{4, "1010", "", "1010"},
		{0, "0101-0101 01", "", "0101-0101 01"},
		{1, "0000-0000 00", "1111-1111", "0111-1111 10"},
		{2, "1111-1111 11", "0011", "1111-0011 11"},
		{3, "1100-1010 11", "1010", "1101-1110 11"},
		{10, "0101-0101 01", "", "0101-0101 01"},
		{1, "1111-0101 01", "1", "1011-0101 01"},
		{9, "1111-1111 11", "1", "1111-1111 10"},
		{6, "0000-0000 0000-0000 000", "1111-1111 1", "0000-0011 1111-1110 000"},
		{6, "1111-1111 1111-1111 111", "1111-1111 1", "1111-1100 0000-0001 111"},
		{7, "1111-1111 1111-1111 111", "1", "1111-1110 1111-1111 111"},
		{8, "1111-1111 1111-1111 111", "1", "1111-1111 0111-1111 111"},
		{9, "1111-1111 1111-1111 111", "1", "1111-1111 1011-1111 111"},
		{5, "0000-1111 0000-0000 000", "111", "0000-1000 0000-0000 000"},
		{6, "0000-1111 0000-0000 000", "111", "0000-1100 1000-0000 000"},
		{7, "0000-1111 0000-0000 000", "111", "0000-1110 1100-0000 000"},
		{8, "0000-1111 0000-0000 000", "111", "0000-1111 1110-0000 000"},
		{5, "1111-0000 1111-0000 1111-0000", "1111-1111 1111-1111", "1111-0111 0000-1111 0000-1000"},
		{6, "1111-0000 1111-0000 1111-0000", "1111-1111 1111-1111", "1111-0011 0000-1111 0000-1100"},
		{8, "0000-0000 1010-0101 0000-0000 00", "1111-0000", "0000-0000 0101-0101 0000-0000 00"},
		// TODO: more test cases
	}
	chk := func(got, want *bitarray.BitArray) {
		t.Helper()
		got.V()
		if !got.Equal(want) {
			t.Error("unexpected result:")
			t.Logf(" got: %#b", got)
			t.Logf(" got: %s", got.D())
			t.Logf("want: %#b", want)
		}
	}
	for _, tc := range tcs {
		ba0 := bitarray.MustParse(tc.src).ZOptimize()
		ba0E := ba0.ZExpand()
		ba1 := bitarray.MustParse(tc.mask).ZOptimize()
		ba1E := ba1.ZExpand()
		want := bitarray.MustParse(tc.dst)
		chk(ba0.XorAt(tc.off, ba1), want)
		chk(ba0.XorAt(tc.off, ba1E), want)
		chk(ba0E.XorAt(tc.off, ba1), want)
		chk(ba0E.XorAt(tc.off, ba1E), want)
	}
	// panics
	bap := bitarray.MustParse("1111")
	chkpanic := func(off int, xs string) {
		t.Helper()
		var ba *bitarray.BitArray
		x := bitarray.MustParse(xs)
		defer func() {
			t.Helper()
			if recover() == nil {
				t.Errorf("panic expected: off=%d, x=%#b: got %#b", off, x, ba)
			}
		}()
		ba = bap.XorAt(off, x)
	}
	chkpanic(-1, "010")
	chkpanic(0, "01010")
	chkpanic(3, "01")
}
