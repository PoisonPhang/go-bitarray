// Copyright (c) 2021 Hirotsuna Mizuno. All rights reserved.
// Use of this source code is governed by the MIT license that can be found in
// the LICENSE file.

package bitarray_test

import (
	"testing"

	"github.com/tunabay/go-bitarray"
)

// also tests PutUint8
func TestBuffer_Uint8(t *testing.T) {
	tcs := []struct {
		s string
		v uint8
	}{
		{"", 0},
		{"0", 0},
		{"1", 1},
		{"00", 0b_00},
		{"01", 0b_01},
		{"11", 0b_11},
		{"000000", 0b_000000},
		{"000001", 0b_000001},
		{"100000", 0b_100000},
		{"111111", 0b_111111},
		{"011111", 0b_011111},
		{"111110", 0b_111110},
		{"0000000", 0b_0000000},
		{"0000001", 0b_0000001},
		{"1000000", 0b_1000000},
		{"1000111", 0b_1000111},
		{"1100000", 0b_1100000},
		{"1100111", 0b_1100111},
		{"1111111", 0b_1111111},
		{"00000000", 0b_00000000},
		{"00000001", 0b_00000001},
		{"00001111", 0b_00001111},
		{"10000000", 0b_10000000},
		{"11110000", 0b_11110000},
		{"11111111", 0b_11111111},
		{"000000001", 0b_00000000},
		{"000000011", 0b_00000001},
		{"100000001", 0b_10000000},
		{"111111110", 0b_11111111},
		{"0000000011111111", 0b_00000000},
		{"1000000111111111", 0b_10000001},
		{"1000000100000000", 0b_10000001},
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				pre := pad.Repeat(prefix)
				for suffix := 0; suffix < 10; suffix++ {
					suf := pad.Repeat(suffix)
					ba := bitarray.Join([]*bitarray.BitArray{pre, core, suf}, nil)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf = buf.Slice(prefix, prefix+core.Len())
					if got := buf.Uint8(); got != tc.v {
						t.Errorf("unexpected result: got %d, want %d", got, tc.v)
						t.Logf(" buf: %#b", buf)
						t.Logf("core: %#b", core)
					}
				}
			}
		}
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		clen := core.Len()
		if 8 < clen {
			continue // skip
		}
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				for suffix := 0; suffix < 10; suffix++ {
					ba := pad.Repeat(prefix + clen + suffix)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf.Slice(prefix, prefix+clen).PutUint8(tc.v)
					got := buf.BitArray().Slice(prefix, prefix+clen)
					if !got.Equal(core) {
						t.Errorf(
							"unexpected result: v=%d, pre=%d, suf=%d",
							tc.v, prefix, suffix,
						)
						t.Logf(" got: %#b", got)
						t.Logf("want: %#b", core)
						t.Logf(" buf: %#b", buf)
					}
				}
			}
		}
	}
}

// also tests PutUint16
func TestBuffer_Uint16(t *testing.T) {
	tcs := []struct {
		s string
		v uint16
	}{
		{"", 0},
		{"0", 0},
		{"1", 1},
		{"00", 0b_00},
		{"01", 0b_01},
		{"11", 0b_11},
		{"11110001", 0b_11110001},
		{"111100011", 0b_111100011},
		{"00000000000000", 0b_00000000000000},
		{"00000000000001", 0b_00000000000001},
		{"10000000000000", 0b_10000000000000},
		{"11111111111111", 0b_11111111111111},
		{"01111111111111", 0b_01111111111111},
		{"11111111111110", 0b_11111111111110},
		{"000000000000000", 0b_000000000000000},
		{"000000000000001", 0b_000000000000001},
		{"100000000000000", 0b_100000000000000},
		{"100000000000111", 0b_100000000000111},
		{"110000000000000", 0b_110000000000000},
		{"110000000000111", 0b_110000000000111},
		{"111111111111111", 0b_111111111111111},
		{"0000000000000000", 0b_0000000000000000},
		{"0000000000000001", 0b_0000000000000001},
		{"0000000000001111", 0b_0000000000001111},
		{"1000000000000000", 0b_1000000000000000},
		{"1111000000000000", 0b_1111000000000000},
		{"1111000011111100", 0b_1111000011111100},
		{"1111111111111111", 0b_1111111111111111},
		{"00000000000000001", 0b_0000000000000000},
		{"00000000000000011", 0b_0000000000000001},
		{"10000000000000001", 0b_1000000000000000},
		{"11111111111111110", 0b_1111111111111111},
		{"00000000000000001111111111111111", 0b_0000000000000000},
		{"10000000000000011111111111111111", 0b_1000000000000001},
		{"10000000000000010000000000000000", 0b_1000000000000001},
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				pre := pad.Repeat(prefix)
				for suffix := 0; suffix < 10; suffix++ {
					suf := pad.Repeat(suffix)
					ba := bitarray.Join([]*bitarray.BitArray{pre, core, suf}, nil)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf = buf.Slice(prefix, prefix+core.Len())
					if got := buf.Uint16(); got != tc.v {
						t.Errorf("unexpected result: got %d, want %d", got, tc.v)
						t.Logf(" buf: %#b", buf)
						t.Logf("core: %#b", core)
					}
				}
			}
		}
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		clen := core.Len()
		if 16 < clen {
			continue // skip
		}
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				for suffix := 0; suffix < 10; suffix++ {
					ba := pad.Repeat(prefix + clen + suffix)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf.Slice(prefix, prefix+clen).PutUint16(tc.v)
					got := buf.BitArray().Slice(prefix, prefix+clen)
					if !got.Equal(core) {
						t.Errorf(
							"unexpected result: v=%d, pre=%d, suf=%d",
							tc.v, prefix, suffix,
						)
						t.Logf(" got: %#b", got)
						t.Logf("want: %#b", core)
						t.Logf(" buf: %#b", buf)
					}
				}
			}
		}
	}
}

// also tests PutUint32
func TestBuffer_Uint32(t *testing.T) {
	tcs := []struct {
		s string
		v uint32
	}{
		{"", 0},
		{"0", 0},
		{"1", 1},
		{"00", 0b_00},
		{"01", 0b_01},
		{"11", 0b_11},
		{"11110001", 0b_11110001},
		{"111100011", 0b_111100011},
		{"000000000000000000000000000000", 0b_000000000000000000000000000000},
		{"000000000000000000000000000001", 0b_000000000000000000000000000001},
		{"100000000000000000000000000000", 0b_100000000000000000000000000000},
		{"111111111111111111111111111111", 0b_111111111111111111111111111111},
		{"011111111111111111111111111111", 0b_011111111111111111111111111111},
		{"111111111111111111111111111110", 0b_111111111111111111111111111110},
		{"0000000000000000000000000000000", 0b_0000000000000000000000000000000},
		{"0000000000000000000000000000001", 0b_0000000000000000000000000000001},
		{"1000000000000000000000000000000", 0b_1000000000000000000000000000000},
		{"1000000000000000000000000000111", 0b_1000000000000000000000000000111},
		{"1100000000000000000000000000000", 0b_1100000000000000000000000000000},
		{"1100000000000000000000000000111", 0b_1100000000000000000000000000111},
		{"1111111111111111111111111111111", 0b_1111111111111111111111111111111},
		{"00000000000000000000000000000000", 0b_00000000000000000000000000000000},
		{"00000000000000000000000000000001", 0b_00000000000000000000000000000001},
		{"00000000000000000000000000001111", 0b_00000000000000000000000000001111},
		{"10000000000000000000000000000000", 0b_10000000000000000000000000000000},
		{"11110000000000000000000000000000", 0b_11110000000000000000000000000000},
		{"11110000101000001100000011111100", 0b_11110000101000001100000011111100},
		{"11111111111111111111111111111111", 0b_11111111111111111111111111111111},
		{"000000000000000000000000000000001", 0b_00000000000000000000000000000000},
		{"000000000000000000000000000000011", 0b_00000000000000000000000000000001},
		{"100000000000000000000000000000001", 0b_10000000000000000000000000000000},
		{"111111111111111111111111111111110", 0b_11111111111111111111111111111111},
		{"000000000000000000000000000000001111111111111111", 0b_00000000000000000000000000000000},
		{"100000000000000000000000000000011111111111111111", 0b_10000000000000000000000000000001},
		{"100000000000000000000000000000010000000000000000", 0b_10000000000000000000000000000001},
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				pre := pad.Repeat(prefix)
				for suffix := 0; suffix < 10; suffix++ {
					suf := pad.Repeat(suffix)
					ba := bitarray.Join([]*bitarray.BitArray{pre, core, suf}, nil)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf = buf.Slice(prefix, prefix+core.Len())
					if got := buf.Uint32(); got != tc.v {
						t.Errorf("unexpected result: got %d, want %d", got, tc.v)
						t.Logf(" buf: %#b", buf)
						t.Logf("core: %#b", core)
					}
				}
			}
		}
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		clen := core.Len()
		if 32 < clen {
			continue // skip
		}
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				for suffix := 0; suffix < 10; suffix++ {
					ba := pad.Repeat(prefix + clen + suffix)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf.Slice(prefix, prefix+clen).PutUint32(tc.v)
					got := buf.BitArray().Slice(prefix, prefix+clen)
					if !got.Equal(core) {
						t.Errorf(
							"unexpected result: v=%d, pre=%d, suf=%d",
							tc.v, prefix, suffix,
						)
						t.Logf(" got: %#b", got)
						t.Logf("want: %#b", core)
						t.Logf(" buf: %#b", buf)
					}
				}
			}
		}
	}
}

// also tests PutUint64
func TestBuffer_Uint64(t *testing.T) {
	tcs := []struct {
		s string
		v uint64
	}{
		{"", 0},
		{"0", 0},
		{"1", 1},
		{"00", 0b_00},
		{"01", 0b_01},
		{"11", 0b_11},
		{"11110001", 0b_11110001},
		{"111100011", 0b_111100011},
		{
			"00000000000000000000000000000000000000000000000000000000000000",
			0b_00000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"00000000000000000000000000000000000000000000000000000000000001",
			0b_00000000000000000000000000000000000000000000000000000000000001,
		},
		{
			"10000000000000000000000000000000000000000000000000000000000000",
			0b_10000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"11111111111111111111111111111111111111111111111111111111111111",
			0b_11111111111111111111111111111111111111111111111111111111111111,
		},
		{
			"01111111111111111111111111111111111111111111111111111111111111",
			0b_01111111111111111111111111111111111111111111111111111111111111,
		},
		{
			"11111111111111111111111111111111111111111111111111111111111110",
			0b_11111111111111111111111111111111111111111111111111111111111110,
		},
		{
			"000000000000000000000000000000000000000000000000000000000000000",
			0b_000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"000000000000000000000000000000000000000000000000000000000000001",
			0b_000000000000000000000000000000000000000000000000000000000000001,
		},
		{
			"100000000000000000000000000000000000000000000000000000000000000",
			0b_100000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"100000000000000000000000000000000000000000000000000000000000111",
			0b_100000000000000000000000000000000000000000000000000000000000111,
		},
		{
			"110000000000000000000000000000000000000000000000000000000000000",
			0b_110000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"110000000000000000000000000000000000000000000000000000000000111",
			0b_110000000000000000000000000000000000000000000000000000000000111,
		},
		{
			"111111111111111111111111111111111111111111111111111111111111111",
			0b_111111111111111111111111111111111111111111111111111111111111111,
		},
		{
			"0000000000000000000000000000000000000000000000000000000000000000",
			0b_0000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"0000000000000000000000000000000000000000000000000000000000000001",
			0b_0000000000000000000000000000000000000000000000000000000000000001,
		},
		{
			"0000000000000000000000000000000000000000000000000000000000001111",
			0b_0000000000000000000000000000000000000000000000000000000000001111,
		},
		{
			"1000000000000000000000000000000000000000000000000000000000000000",
			0b_1000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"1111000000000000000000000000000000000000000000000000000000000000",
			0b_1111000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"1111000010100000110000001111110011100000110011001101000010111100",
			0b_1111000010100000110000001111110011100000110011001101000010111100,
		},
		{
			"1111111111111111111111111111111111111111111111111111111111111111",
			0b_1111111111111111111111111111111111111111111111111111111111111111,
		},
		{
			"00000000000000000000000000000000000000000000000000000000000000001",
			0b_0000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"00000000000000000000000000000000000000000000000000000000000000011",
			0b_0000000000000000000000000000000000000000000000000000000000000001,
		},
		{
			"10000000000000000000000000000000000000000000000000000000000000001",
			0b_1000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"11111111111111111111111111111111111111111111111111111111111111110",
			0b_1111111111111111111111111111111111111111111111111111111111111111,
		},
		{
			"00000000000000000000000000000000000000000000000000000000000000001111111111111111",
			0b_0000000000000000000000000000000000000000000000000000000000000000,
		},
		{
			"10000000000000000000000000000000000000000000000000000000000000011111111111111111",
			0b_1000000000000000000000000000000000000000000000000000000000000001,
		},
		{
			"10000000000000000000000000000000000000000000000000000000000000010000000000000000",
			0b_1000000000000000000000000000000000000000000000000000000000000001,
		},
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				pre := pad.Repeat(prefix)
				for suffix := 0; suffix < 10; suffix++ {
					suf := pad.Repeat(suffix)
					ba := bitarray.Join([]*bitarray.BitArray{pre, core, suf}, nil)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf = buf.Slice(prefix, prefix+core.Len())
					if got := buf.Uint64(); got != tc.v {
						t.Errorf("unexpected result: got %d, want %d", got, tc.v)
						t.Logf(" buf: %#b", buf)
						t.Logf("core: %#b", core)
					}
				}
			}
		}
	}
	for _, tc := range tcs {
		core := bitarray.MustParse(tc.s)
		clen := core.Len()
		if 64 < clen {
			continue // skip
		}
		for padbit := byte(0); padbit < 2; padbit++ {
			pad := bitarray.New(padbit)
			for prefix := 0; prefix < 18; prefix++ {
				for suffix := 0; suffix < 10; suffix++ {
					ba := pad.Repeat(prefix + clen + suffix)
					buf := bitarray.NewBufferFromBitArray(ba)
					buf.Slice(prefix, prefix+clen).PutUint64(tc.v)
					got := buf.BitArray().Slice(prefix, prefix+clen)
					if !got.Equal(core) {
						t.Errorf(
							"unexpected result: v=%d, pre=%d, suf=%d",
							tc.v, prefix, suffix,
						)
						t.Logf(" got: %#b", got)
						t.Logf("want: %#b", core)
						t.Logf(" buf: %#b", buf)
					}
				}
			}
		}
	}
}
